/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package pl.mati.arkanoidms;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Random;
import javax.swing.Timer;

/**
 *
 * @author mateusz
 */
public class GamePanel extends javax.swing.JPanel implements ActionListener{

    private static final long serialVersionUID = 1L;
    
    private final int WINDOW_WIDTH = 600;
    private final int WINDOW_HEIGHT = 500;
    private final int paletteWidth = 100;
    private final int paletteHeight = 10;
    private int xPalette = (WINDOW_WIDTH - paletteWidth) / 2;
    private final int yPalette = WINDOW_HEIGHT - paletteHeight;
    private final int ballDiameter = 20;
    private int xBall = (WINDOW_WIDTH - ballDiameter) / 2;
    private int yBall = (WINDOW_HEIGHT - ballDiameter) / 2;
    private final Random generator = new Random();
    private final int rows = generator.nextInt(5) + 4;
    private final int columns = generator.nextInt(5) + 4;
    private final int brickWidth = 50;
    private final int brickHeight = 10;
    private final int bricksSpacing = 5;
    private final int bricksSpacingLeft = (WINDOW_WIDTH- (brickWidth * columns + bricksSpacing * (columns - 1))) / 2;
    private final int bricksSpacingTop = 10;
    private final int bricksX[][] = new int[columns][rows];
    private final int bricksY[][] = new int[columns][rows];
    private final boolean orBroken[][] = new boolean[columns][rows];
    private int dx = 2;
    private int dy = -2;
    private final Timer timer;
    private String gameState = "Trwa";
    
    /**
     * Creates new form GamePanel
     */
    public GamePanel() {
        initComponents();
        setBackground(Color.blue);
        setPreferredSize(new Dimension(WINDOW_WIDTH, WINDOW_HEIGHT));
        
        for (int i = 0; i < columns; i++){
            for (int j = 0; j < rows; j++){
                bricksX[i][j] = i * (brickWidth + bricksSpacing) + bricksSpacingLeft;
                bricksY[i][j] = j * (brickHeight + bricksSpacing) + bricksSpacingTop;
                orBroken[i][j] = false;
            }
        }
        timer = new Timer(10, this);
        timer.start();
        addKeyListener(new Control());
        setFocusable(true);
    }

    @Override
    public void paintComponent(Graphics g){
        super.paintComponent(g);
        draw(g);
    };
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void draw(Graphics g) {
        if(gameState.equals("Trwa")){
            drawPalette(g);
            drawBall(g);
            drawBricks(g);
        } else {
            theEnd(g);
        }       
    }

    private void drawPalette(Graphics g){
        g.setColor(Color.green);
        g.fillRect(xPalette, yPalette, paletteWidth, paletteHeight);
        g.setColor(Color.white);
        g.drawRect(xPalette, yPalette, paletteWidth, paletteHeight);
    }
    
    private void drawBall(Graphics g){
        g.setColor(Color.green);
        g.fillOval(xBall, yBall, ballDiameter, ballDiameter);
        g.setColor(Color.white);
        g.drawOval(xBall, yBall, ballDiameter, ballDiameter);
    }
    
    private void drawBricks(Graphics g){
        for (int i = 0; i < columns; i++){
            for(int j = 0; j < rows; j++){
                if (!orBroken[i][j]){
                    g.setColor(Color.green);
                    g.fillRect(bricksX[i][j], bricksY[i][j], brickWidth, brickHeight);
                    g.setColor(Color.white);
                    g.drawRect(bricksX[i][j], bricksY[i][j], brickWidth, brickHeight);
                }
            }
        }
    }

    private void ballMovement(){
        if(xBall <= 0 || xBall > WINDOW_WIDTH - ballDiameter){
            dx *= -1;
        }
        if(yBall <= 0 || yBall + ballDiameter >= yPalette && xBall > xPalette && xBall < xPalette + paletteWidth){
            dy *= -1;
        }
        xBall += dx;
        yBall += dy;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        checkTheGameStatus();
        colisionWithBrick();
        ballMovement();
        repaint(); //To change body of generated methods, choose Tools | Templates.
    }
    
    private class Control extends KeyAdapter{
        @Override
        public void keyPressed(KeyEvent e){
            int key = e.getKeyCode();
            
            if(key == KeyEvent.VK_LEFT && xPalette > 0){
                xPalette -= 10;
            }
            if(key == KeyEvent.VK_RIGHT && xPalette < WINDOW_WIDTH - paletteWidth){
                xPalette += 10;
            }
        }
    }
    
    private void colisionWithBrick(){
        for (int i = 0; i < columns; i++){
            for (int j = 0; j < rows; j++){
                if (orBroken[i][j] == false){
                    if (xBall > bricksX[i][j]
                            && xBall < bricksX[i][j] + brickWidth
                            && yBall < bricksY[i][j] + brickHeight //&& yBall < bricksY[i][j] + brickHeight
                            && yBall + ballDiameter > bricksY[i][j]) {
                        dy = -dy;
                        orBroken[i][j] = true;
                    } else if (yBall > bricksY[i][j]
                            && yBall < bricksY[i][j] + brickHeight
                            && xBall < bricksX[i][j] + brickWidth
                            && xBall + ballDiameter > bricksX[i][j]){
                        dx = -dx;
                        orBroken[i][j] = true;
                    }            
                }
            }
        }
    }
    
    private void checkTheGameStatus(){
        if (yBall > WINDOW_HEIGHT){
            gameState = "PRZEGRYWASZ";
        }
        int irrefutable = 0;
        for (int i = 0; i < columns; i++){
            for (int j = 0; j < rows; j++){
                if (orBroken[i][j] == false){
                    irrefutable++;
                }
            }
        }
        if (irrefutable == 0){
            gameState = "Wygrywasz!";
        }
    }

    private void theEnd(Graphics graphics){
        Font font = new Font("Sans-serif", Font.BOLD, 14); 
        FontMetrics metrics = getFontMetrics(font);
        graphics.setColor(Color.white);
        graphics.setFont(font);
        graphics.drawString(gameState, (WINDOW_WIDTH - metrics.stringWidth(gameState)) / 2, WINDOW_HEIGHT / 2);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
